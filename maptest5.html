<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pylon Placement Puzzle (64x36 Grid) - Dynamic Controls</title>
    <style>
        /* General layout and centering */
        body { 
            font-family: sans-serif; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            min-height: 100vh; 
            background-color: #222; 
            color: #eee; 
            margin: 0; 
            padding: 20px; 
            gap: 10px; /* Reduced gap for tighter layout */
        }
        #top-container { 
            display: flex; 
            flex-direction: row; 
            gap: 20px; 
            /* Fix: Use a container aligned with the map's width as the reference */
            position: relative;
            /* Ensure the overall page structure is centered based on the total block width */
            width: 1344px; /* 1024 (Map) + 300 (Sidebar) + 20 (Gap) */
        }
        
        /* Canvas dimensions: 16:9 ratio (1024x576) */
        #map-and-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            flex-shrink: 0;
        }

        canvas { 
            border: 1px solid #555; 
            background-color: #333; 
            width: 1024px; 
            height: 576px; 
            cursor: grab;
        }
        canvas.dragging {
            cursor: grabbing;
        }
        #controls { 
            background-color: #444; 
            padding: 20px; 
            border-radius: 8px; 
            box-shadow: 0 0 10px rgba(0,0,0,0.5); 
            width: 300px; 
            margin-top: 0; 
            box-sizing: border-box;
            flex-shrink: 0;
        }
        .control-group { margin-bottom: 15px; padding-bottom: 15px; border-bottom: 1px solid #555; }
        .control-group:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }
        label { display: block; margin-bottom: 5px; font-weight: bold; }
        select, input[type="range"], input[type="number"], button {
            width: calc(100% - 10px); padding: 8px; margin-bottom: 10px; border-radius: 4px;
            border: 1px solid #666; background-color: #555; color: #eee; appearance: none; 
        }
        button { cursor: pointer; background-color: #007bff; border-color: #007bff; }
        button:hover { background-color: #0056b3; border-color: #0056b3; }
        h3 { margin-top: 0; color: #fff; }
        .component-list { max-height: 200px; overflow-y: auto; background-color: #555; padding: 10px; border-radius: 4px; border: 1px solid #666; margin-top: 10px; }
        .component-list div { padding: 3px 0; font-size: 0.9em; }
        
        /* Validation Colors */
        .pass { color: #0f0; } 
        .fail { color: lightcoral; } 
        .solved { font-weight: bold; font-size: 1.2em; color: #0f0; text-align: center; }
        .not-solved { font-weight: bold; font-size: 1.2em; color: lightcoral; text-align: center; }

        /* --- PT Controls Bar Below Map --- */
        #pt-control-bar {
            width: 1024px; 
            max-height: 250px;
            overflow-y: auto;
            padding: 10px;
            background-color: #333;
            border-radius: 8px;
            border: 1px solid #555;
            display: flex; 
            flex-wrap: wrap;
            gap: 10px;
            justify-content: flex-start;
        }
        .pt-control-box {
            flex: 0 0 calc(1024px / 9 - 11px); 
            max-width: calc(1024px / 9 - 11px);
            box-sizing: border-box; 
            background-color: #444;
            padding: 8px;
            border-radius: 4px;
            border-left: 3px solid #007bff;
            font-size: 0.8em;
            cursor: pointer;
        }
        .pt-control-box h5 {
            margin: 0;
            color: skyblue;
            font-size: 0.9em;
            text-align: center;
        }
        .control-status-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2px;
            font-size: 0.8em;
        }
        .control-status-row select, .control-status-row button {
            width: 45%;
            margin: 0;
            padding: 2px;
            font-size: 0.75em;
        }
        .live-ch-status {
            font-weight: bold;
            font-size: 0.8em;
        }
        .control-disabled {
            opacity: 0.5;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="top-container">
        
        <div id="map-and-controls">
            <canvas id="networkCanvas" width="1024" height="576"></canvas>
            <div id="pt-control-bar">
                </div>
        </div>

        <div id="controls">
            <h3>Pylon Puzzle Controls</h3>
            <div class="control-group">
                <label for="solveState">Select Solve State:</label>
                <select id="solveState">
                    <option value="state1">Solve State 1 (PT-A to L)</option>
                    <option value="state2">Solve State 2 (PT-M to R)</option>
                    <option value="custom">Custom (Manual Control)</option>
                </select>
                <label for="selectedPT">Select PT to Inspect:</label>
                <select id="selectedPT"></select>
            </div>

            <div class="control-group">
                <label>Coverage Summary:</label>
                <div id="coverageDetails" class="component-list"></div>
            </div>
            <div class="control-group">
                <label>Active PT Validation:</label>
                <div id="currentPTStates" class="component-list"></div>
            </div>
            <div class="control-group">
                <label>Distances from Selected PT:</label>
                <div id="distances" class="component-list"></div>
            </div>
            
            <div class="control-group">
                <label>Current Component Coordinates (X/Y):</label>
                <div id="coordinateOutput" class="component-list">
                    </div>
            </div>
        </div>
    </div>

    <script>
        // --- GLOBAL CONSTANTS & SETUP ---
        const canvas = document.getElementById('networkCanvas');
        const ctx = canvas.getContext('2d');
        const gridSizeX = 64; 
        const gridSizeY = 36; 
        const UNIT_PIXELS = canvas.height / gridSizeY; // 16
        const canvasWidth = 1024;
        const canvasHeight = 576; 
        const RT_FIXED_RADIUS = 4.0; // RTs fixed at 4.0U

        // Radii Mapping: P3 = 5.0U, P4 = 7.0U
        const powerRadii = { 0: 0.0, 1: 1.0, 2: 3.0, 3: 5.0, 4: 7.0 };

        // === ALL MAP DATA: FINAL PT and 24 RT PLACEMENT ===

        const components = [
            // --- PTs A-L (Original State 1 Active Group) ---
            { id: 'PT-A', type: 'PT', x: 9.4, y: 11.1, active: false, power: 0, reqPower: 3, reqChannel: 1 }, 
            { id: 'PT-B', type: 'PT', x: 8.0,  y: 31.0, active: false, power: 0, reqPower: 3, reqChannel: 1 },
            { id: 'PT-C', type: 'PT', x: 16.0, y: 18.0, active: false, power: 0, reqPower: 4, reqChannel: 2 }, 
            { id: 'PT-D', type: 'PT', x: 19.9, y: 4.9,  active: false, power: 0, reqPower: 3, reqChannel: 1 },
            { id: 'PT-E', type: 'PT', x: 21.0, y: 31.1, active: false, power: 0, reqPower: 3, reqChannel: 1 },
            { id: 'PT-F', type: 'PT', x: 32.0, y: 12.0, active: false, power: 0, reqPower: 4, reqChannel: 3 }, 
            { id: 'PT-G', type: 'PT', x: 32.0, y: 29.0, active: false, power: 0, reqPower: 4, reqChannel: 3 }, 
            { id: 'PT-H', type: 'PT', x: 43.0, y: 5.9,  active: false, power: 0, reqPower: 3, reqChannel: 1 },
            { id: 'PT-I', type: 'PT', x: 41.9, y: 31.1, active: false, power: 0, reqPower: 3, reqChannel: 1 },
            { id: 'PT-J', type: 'PT', x: 48.5, y: 18.1, active: false, power: 0, reqPower: 4, reqChannel: 2 }, 
            { id: 'PT-K', type: 'PT', x: 56.8, y: 4.8,  active: false, power: 0, reqPower: 3, reqChannel: 1 }, 
            { id: 'PT-L', type: 'PT', x: 54.2, y: 32.8, active: false, power: 0, reqPower: 3, reqChannel: 1 },

            // --- PTs M-R (Original State 2 Active Group) ---
            { id: 'PT-M', type: 'PT', x: 37.8, y: 19.5, active: false, power: 0, reqPower: 4, reqChannel: 2 },
            { id: 'PT-N', type: 'PT', x: 7.5, y: 19.8, active: false, power: 0, reqPower: 4, reqChannel: 2 },
            { id: 'PT-O', type: 'PT', x: 25.0, y: 23.3, active: false, power: 0, reqPower: 4, reqChannel: 3 },
            { id: 'PT-P', type: 'PT', x: 57.8, y: 14.4, active: false, power: 0, reqPower: 4, reqChannel: 2 },
            { id: 'PT-Q', type: 'PT', x: 55.7, y: 27.5, active: false, power: 0, reqPower: 4, reqChannel: 2 },
            { id: 'PT-R', type: 'PT', x: 32.0, y: 2.2,  active: false, power: 0, reqPower: 3, reqChannel: 1 }, 
            
            // --- REPEATER TOWERS (RTs) - (Total 24 RTs) ---
            { id: 'RT1', type: 'RT', x: 5.6, y: 5.7 },
            { id: 'RT2', type: 'RT', x: 14.2, y: 12.3 },
            { id: 'RT3', type: 'RT', x: 4.0, y: 32.9 },
            { id: 'RT4', type: 'RT', x: 24.5, y: 6.4 },
            { id: 'RT5', type: 'RT', x: 9.4, y: 18.0 },
            { id: 'RT6', type: 'RT', x: 36.5, y: 23.6 },
            { id: 'RT7', type: 'RT', x: 37.2, y: 9.8 },
            { id: 'RT8', type: 'RT', x: 22.0, y: 26.8 },
            { id: 'RT9', type: 'RT', x: 33.2, y: 18.4 },
            { id: 'RT10', type: 'RT', x: 27.5, y: 33.3 },
            { id: 'RT11', type: 'RT', x: 35.8, y: 33.7 },
            { id: 'RT12', type: 'RT', x: 25.4, y: 11.2 },
            { id: 'RT13', type: 'RT', x: 29.2, y: 23.0 },
            { id: 'RT14', type: 'RT', x: 50.2, y: 12.3 },
            { id: 'RT15', type: 'RT', x: 54.6, y: 18.1 },
            { id: 'RT16', type: 'RT', x: 9.0, y: 22.2 },
            { id: 'RT17', type: 'RT', x: 41.6, y: 27.1 },
            { id: 'RT18', type: 'RT', x: 52.6, y: 30.8 },
            { id: 'RT19', type: 'RT', x: 59.6, y: 3.8 },
            { id: 'RT20', type: 'RT', x: 47.6, y: 7.1 },
            { id: 'RT21', type: 'RT', x: 25.8, y: 18.9 },
            { id: 'RT22', type: 'RT', x: 61.6, y: 11.6 }, 
            { id: 'RT23', type: 'RT', x: 32.8, y: 2.5 }, 
            { id: 'RT24', type: 'RT', x: 60.0, y: 30.0 },

            // --- CITIES (C) - N=12 ---
            { id: 'C1', type: 'C', x: 1.0, y: 14.0 },
            { id: 'C2', type: 'C', x: 1.0, y: 22.0 },
            { id: 'C3', type: 'C', x: 18.0, y: 18.0 },
            { id: 'C4', type: 'C', x: 18.0, y: 26.0 },
            { id: 'C5', type: 'C', x: 28.0, y: 14.0 },
            { id: 'C6', type: 'C', x: 28.0, y: 22.0 },
            { id: 'C7', type: 'C', x: 46.0, y: 14.0 },
            { id: 'C8', type: 'C', x: 46.0, y: 22.0 },
            { id: 'C9', type: 'C', x: 62.0, y: 18.0 },
            { id: 'C10', type: 'C', x: 32.0, y: 6.0 },
            { id: 'C11', type: 'C', x: 32.0, y: 34.0 },
            { id: 'C12', type: 'C', x: 62.0, y: 26.0 }
        ];


        // === MOUNTAIN DATA (6 Smaller Rectangles, Unchanged) ===
        const mountains = [
            { id: 'M1', x: 10, y: 14, w: 4, h: 3 }, 
            { id: 'M2', x: 10, y: 19, w: 4, h: 3 }, 
            { id: 'M3', x: 28, y: 8, w: 4, h: 3 },  
            { id: 'M4', x: 32, y: 25, w: 4, h: 3 }, 
            { id: 'M5', x: 50, y: 14, w: 4, h: 3 },
            { id: 'M6', x: 50, y: 19, w: 4, h: 3 }  
        ];

        // --- Global State & UI Elements ---
        let rtStates = {}; 
        let currentSolveState = 'custom';
        const selectedPTSelect = document.getElementById('selectedPT');
        const solveStateSelect = document.getElementById('solveState');
        const bottomPtControlsDiv = document.getElementById('pt-control-bar'); 
        const distancesDiv = document.getElementById('distances');
        const coverageDetailsDiv = document.getElementById('coverageDetails');
        const currentPTStatesDiv = document.getElementById('currentPTStates');
        const coordinateOutputDiv = document.getElementById('coordinateOutput');

        let dragTarget = null;
        let dragOffsetX = 0;
        let dragOffsetY = 0;

        // --- CORE HANDLER FUNCTIONS (MUST BE DEFINED EARLY) ---

        function handleControlChange(event) {
            const target = event.target;
            if (target.tagName === 'SELECT') {
                const ptId = target.id.split('-')[2];
                const type = target.getAttribute('data-type');
                const newValue = parseInt(target.value);

                const pt = components.find(c => c.id === ptId);
                if (pt) {
                    if (currentSolveState !== 'custom') {
                        solveStateSelect.value = 'custom';
                        currentSolveState = 'custom';
                    }

                    if (type === 'power') {
                        pt.power = newValue;
                        pt.active = newValue > 0;
                    } else if (type === 'reqChannel') {
                        pt.reqChannel = newValue;
                    }
                }
                updateControlPanel();
            }
        }

        function handleControlClick(event) {
            const target = event.target;
            if (target.tagName === 'BUTTON' && target.id.startsWith('toggle-')) {
                const ptId = target.getAttribute('data-pt-id');
                togglePT(ptId);
            } else if (target.closest('.pt-control-box')) {
                const ptId = target.closest('.pt-control-box').id.split('-')[1];
                selectPT(ptId);
            }
        }
        
        function togglePT(ptId) {
            const pt = components.find(c => c.id === ptId);
            if (pt) {
                if (currentSolveState !== 'custom') {
                    solveStateSelect.value = 'custom';
                    currentSolveState = 'custom';
                }

                pt.active = !pt.active;
                
                if (pt.active && pt.power === 0) {
                    pt.power = 3; 
                }
                if (!pt.active) {
                    pt.power = 0;
                }
            }
            updateControlPanel();
        }
        
        function selectPT(ptId) {
            selectedPTSelect.value = ptId;
            updateControlPanel(); 
        }

        // --- GEOMETRIC AND BLOCKING LOGIC (Unchanged) ---

        function onSegment(p, q, r) {
            return (q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) &&
                    q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y));
        }

        function orientation(p, q, r) {
            const val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
            if (val === 0) return 0;
            return (val > 0) ? 1 : 2;
        }

        function doIntersect(p1, q1, p2, q2) {
            const o1 = orientation(p1, q1, p2);
            const o2 = orientation(p1, q1, q2);
            const o3 = orientation(p2, q2, p1);
            const o4 = orientation(p2, q2, q1);
            if (o1 !== o2 && o3 !== o4) { return true; }
            if (o1 === 0 && onSegment(p1, p2, q1)) return true;
            if (o2 === 0 && onSegment(p1, q2, q1)) return true;
            if (o3 === 0 && onSegment(p2, p1, q2)) return true;
            if (o4 === 0 && onSegment(p2, q1, q2)) return true;
            return false;
        }

        function isPathBlocked(source, target) {
            const p1 = { x: Number(source.x), y: Number(source.y) };
            const q1 = { x: Number(target.x), y: Number(target.y) };

            for (const mountain of mountains) {
                const m = mountain;
                const p_m1 = { x: m.x, y: m.y };             
                const p_m2 = { x: m.x + m.w, y: m.y };     
                const p_m3 = { x: m.x + m.w, y: m.y + m.h }; 
                const p_m4 = { x: m.x, y: m.y + m.h };     

                if (doIntersect(p1, q1, p_m1, p_m2)) return true; 
                if (doIntersect(p1, q1, p_m2, p_m3)) return true; 
                if (doIntersect(p1, q1, p_m3, p_m4)) return true; 
                if (doIntersect(p1, q1, p_m4, p_m1)) return true; 
            }
            return false;
        }
       
        function getDistance(c1, c2) {
            return Math.sqrt(Math.pow(c1.x - c2.x, 2) + Math.pow(c1.y - c2.y, 2));
        }

        function isSignalSuccessful(source, target, range) {
            const distance = getDistance(source, target);
            if (distance > range) return false;
            if (distance === 0) return false;
            return !isPathBlocked(source, target);
        }
       
        // --- PUZZLE VALIDATION LOGIC (Unchanged) ---
        function getPT_RT_HitCount(pt) {
            if (!pt.active || pt.power === 0) { return 0; }
            const ptRange = powerRadii[pt.power];
            const rts = components.filter(c => c.type === 'RT');
            let hitCount = 0;
            rts.forEach(rt => {
                if (isSignalSuccessful(pt, rt, ptRange)) { hitCount++; }
            });
            return hitCount;
        }

        function doesPtCoverAnyCity(pt, allActiveRTs) {
            if (!pt.active || pt.power === 0) return false;
            const ptRange = powerRadii[pt.power];
            const cities = components.filter(c => c.type === 'C');

            const coversDirectly = cities.some(city => isSignalSuccessful(pt, city, ptRange));
            if (coversDirectly) return true;

            const hitRTs = allActiveRTs.filter(rt => isSignalSuccessful(pt, rt, ptRange));
            if (hitRTs.length === 0) return false; 

            const coversIndirectly = cities.some(city => 
                hitRTs.some(rt => isSignalSuccessful(rt, city, RT_FIXED_RADIUS))
            );
            
            return coversIndirectly;
        }

        function checkAllPuzzleRequirements(state) {
            const activePTs = components.filter(c => c.type === 'PT' && c.active);
            if (activePTs.length === 0) return { isSolved: false, details: [] };

            const allActiveRTs = components.filter(c => c.type === 'RT' && rtStates[c.id]);

            let allReqsMet = true;
            const details = activePTs.map(pt => {
                const liveChannel = getPT_RT_HitCount(pt);
                const channelMet = (liveChannel === pt.reqChannel);
                const cityCoverageMet = doesPtCoverAnyCity(pt, allActiveRTs);

                if (!channelMet || !cityCoverageMet) { allReqsMet = false; }

                return { id: pt.id, liveChannel, reqChannel: pt.reqChannel, channelMet, cityCoverageMet };
            });

            return { isSolved: allReqsMet, details };
        }

        function getCityCoverage() {
            const activeRTs = components.filter(rt => rt.type === 'RT' && rtStates[rt.id]);
            const activePTs = components.filter(pt => pt.type === 'PT' && pt.active && pt.power > 0);

            const allCities = components.filter(c => c.type === 'C');

            const coveredCities = allCities.filter(city => {
                const isHitByPT = activePTs.some(pt => isSignalSuccessful(pt, city, powerRadii[pt.power]));
                if (isHitByPT) return true;
                const isHitByRT = activeRTs.some(rt => isSignalSuccessful(rt, city, RT_FIXED_RADIUS));
                return isHitByRT;
            });
           
            return { coveredCities, totalCities: allCities.length };
        }

        function updateRTStates() {
            components.filter(c => c.type === 'RT').forEach(rt => rtStates[rt.id] = false);

            const activePTs = components.filter(c => c.type === 'PT' && c.active && c.power > 0); 

            components.filter(c => c.type === 'RT').forEach(rt => {
                const isHitByAnyPT = activePTs.some(pt => 
                    isSignalSuccessful(pt, rt, powerRadii[pt.power])
                );
                if (isHitByAnyPT) { rtStates[rt.id] = true; }
            });
        }
       
        // --- RENDERING FUNCTIONS ---
        function drawGrid() {
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 0.5;
           
            for (let i = 0; i <= gridSizeX; i++) {
                ctx.beginPath();
                ctx.moveTo(i * UNIT_PIXELS, 0); 
                ctx.lineTo(i * UNIT_PIXELS, canvasHeight);
                ctx.stroke();
            }
            for (let i = 0; i <= gridSizeY; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * UNIT_PIXELS);
                ctx.lineTo(canvasWidth, i * UNIT_PIXELS); 
                ctx.stroke();
            }

            // Draw Mountains (Rectangular)
            ctx.fillStyle = 'rgba(0, 100, 0, 0.5)'; 
            ctx.strokeStyle = 'darkgreen'; 
            ctx.lineWidth = 2;
           
            mountains.forEach(mountain => {
                const x = mountain.x * UNIT_PIXELS;
                const y = mountain.y * UNIT_PIXELS;
                const w = mountain.w * UNIT_PIXELS;
                const h = mountain.h * UNIT_PIXELS;

                ctx.beginPath();
                ctx.rect(x, y, w, h);
                ctx.fill();
                ctx.stroke();
            });
        }

        // HELPER: Draws the wedge fill
        function drawWedge(ptX, ptY, pixelRadius, color, startAngle, endAngle) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(ptX, ptY); 
            
            if (startAngle > endAngle) {
                ctx.arc(ptX, ptY, pixelRadius, startAngle, endAngle, false); 
            } else {
                ctx.arc(ptX, ptY, pixelRadius, startAngle, endAngle);
            }
            ctx.closePath();
            ctx.fill();
        }
        
        // RAYCASTING DRAW COMPONENTS - Using working logic
        function drawComponents() {
            drawGrid();

            const angleStep = 0.5; 
            const fullCircle = 2 * Math.PI;

            function performRaycasting(component, isPT) {
                const radius = isPT ? powerRadii[component.power] : RT_FIXED_RADIUS;
                if (radius <= 0) return;
                const center_x = component.x * UNIT_PIXELS;
                const center_y = component.y * UNIT_PIXELS;
                const pixel_radius = radius * UNIT_PIXELS;

                let startAngle = 0;
                let lastAngleWasClear = false;
                
                const fill_color = isPT ? 'rgba(0, 191, 255, 0.08)' : 'rgba(255, 255, 0, 0.06)';
                const border_color = isPT ? 'rgba(0, 191, 255, 0.6)' : 'rgba(255, 255, 0, 0.5)';
                const blocked_color = isPT ? 'rgba(0, 100, 255, 0.1)' : 'rgba(255, 165, 0, 0.1)';


                for (let angle = 0; angle <= 360; angle += angleStep) {
                    const currentRadians = angle * (Math.PI / 180);
                    const prevRadians = (angle - angleStep) * (Math.PI / 180);

                    const targetUnit = { 
                        x: center_x / UNIT_PIXELS + radius * Math.cos(currentRadians), 
                        y: center_y / UNIT_PIXELS + radius * Math.sin(currentRadians) 
                    };
                    const isClear = !isPathBlocked(component, targetUnit);

                    if (isClear) {
                        if (!lastAngleWasClear) {
                            startAngle = prevRadians; 
                        }
                        
                        // Draw the visible border segment
                        ctx.strokeStyle = border_color;
                        ctx.lineWidth = 1.5;
                        
                        const prev_x = center_x + pixel_radius * Math.cos(prevRadians);
                        const prev_y = center_y + pixel_radius * Math.sin(prevRadians);
                        const curr_x = center_x + pixel_radius * Math.cos(currentRadians);
                        const curr_y = center_y + pixel_radius * Math.sin(currentRadians);
                        
                        ctx.beginPath();
                        ctx.moveTo(prev_x, prev_y);
                        ctx.lineTo(curr_x, curr_y);
                        ctx.stroke();

                    } else { // Signal is BLOCKED
                        if (lastAngleWasClear) {
                            // END of a clear path. Draw the filled wedge up to the boundary.
                            drawWedge(center_x, center_y, pixel_radius, fill_color, startAngle, currentRadians);
                        }
                        
                        // Draw faded segment (for the block)
                        ctx.strokeStyle = blocked_color; 
                        ctx.lineWidth = 0.5;
                        
                        const near_x = center_x + (pixel_radius * 0.95) * Math.cos(prevRadians);
                        const near_y = center_y + (pixel_radius * 0.95) * Math.sin(prevRadians);
                        
                        const edge_x = center_x + pixel_radius * Math.cos(currentRadians);
                        const edge_y = center_y + pixel_radius * Math.sin(currentRadians);
                        
                        ctx.beginPath();
                        ctx.moveTo(near_x, near_y);
                        ctx.lineTo(edge_x, edge_y);
                        ctx.stroke();
                    }
                    lastAngleWasClear = isClear;
                }

                // Handle wrap-around case (if the segment ends at 360 and started before 0)
                if (lastAngleWasClear) {
                    drawWedge(center_x, center_y, pixel_radius, fill_color, startAngle, fullCircle);
                }
            }
            
            // 1. Draw PT ranges
            components.filter(c => c.type === 'PT' && c.active && c.power > 0).forEach(pt => {
                performRaycasting(pt, true);
            });

            // 2. Draw ACTIVE RT ranges
            components.filter(c => c.type === 'RT' && rtStates[c.id]).forEach(rt => {
                performRaycasting(rt, false);
            });
            
            // 3. Draw components points and labels
            components.forEach(c => {
                const center_x = c.x * UNIT_PIXELS;
                const center_y = c.y * UNIT_PIXELS;
               
                let color = 'white';
                let size = 5;

                if (c.type === 'PT') {
                    color = c.active ? (c.power > 0 ? 'skyblue' : 'darkgray') : 'red';
                    size = 7;
                } else if (c.type === 'RT') {
                    color = rtStates[c.id] ? 'yellow' : '#666'; 
                    size = 6;
                } else if (c.type === 'C') {
                    color = 'lightcoral';
                    size = 4;
                }

                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(center_x, center_y, size, 0, 2 * Math.PI);
                ctx.fill();
               
                ctx.fillStyle = 'white';
                ctx.font = '10px Arial';
                ctx.fillText(c.id, center_x + size + 2, center_y + 3);
            });
        }

        // --- DRAG LOGIC ---
        function getMousePos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (evt.clientX - rect.left) / UNIT_PIXELS,
                y: (evt.clientY - rect.top) / UNIT_PIXELS
            };
        }

        function isPointInComponent(point, component) {
            const size = component.type === 'PT' ? 0.8 : (component.type === 'RT' ? 0.6 : 0.4);
            const dist = getDistance(point, component);
            return dist <= size;
        }
        
        canvas.addEventListener('mousedown', (e) => {
            const mousePos = getMousePos(canvas, e);
            
            const orderedComponents = components.filter(c => c.type === 'C').concat(
                components.filter(c => c.type === 'RT'),
                components.filter(c => c.type === 'PT')
            );
            
            dragTarget = orderedComponents.find(c => isPointInComponent(mousePos, c));

            if (dragTarget) {
                if (currentSolveState !== 'custom') {
                    solveStateSelect.value = 'custom';
                    currentSolveState = 'custom';
                }
                
                canvas.classList.add('dragging');
                dragOffsetX = mousePos.x - dragTarget.x;
                dragOffsetY = mousePos.y - dragTarget.y;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (dragTarget) {
                const mousePos = getMousePos(canvas, e);
                let newX = mousePos.x - dragOffsetX;
                let newY = mousePos.y - dragOffsetY;

                // Clamp to grid boundaries
                newX = Math.max(0.0, Math.min(gridSizeX, newX));
                newY = Math.max(0.0, Math.min(gridSizeY, newY));

                // Update component position
                dragTarget.x = parseFloat(newX.toFixed(1));
                dragTarget.y = parseFloat(newY.toFixed(1));
                
                updateControlPanel();
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (dragTarget) {
                dragTarget = null;
                canvas.classList.remove('dragging');
            }
        });
        
        // --- UI/Logic Functions (Validation & Status) ---

        // New: Outputs the current coordinates and power of all components for easy copying.
        function updateCoordinateOutput() {
            const outputDiv = document.getElementById('coordinateOutput');
            let output = '<b>PT Coordinates (X, Y, Current Pwr):</b><br>';
            
            components.filter(c => c.type === 'PT').forEach(pt => {
                output += `<div>{ id: '${pt.id}', x: ${pt.x.toFixed(1)}, y: ${pt.y.toFixed(1)}, pwr: ${pt.power} },</div>`;
            });
            output += '<hr style="border-color:#555">';
            
            output += '<b>RT Coordinates (X, Y):</b><br>';
            components.filter(c => c.type === 'RT').forEach(rt => {
                output += `<div>{ id: '${rt.id}', type: 'RT', x: ${rt.x.toFixed(1)}, y: ${rt.y.toFixed(1)} },</div>`;
            });
            output += '<hr style="border-color:#555">';

            output += '<b>City Coordinates (X, Y):</b><br>';
            components.filter(c => c.type === 'C').forEach(city => {
                output += `<div>{ id: '${city.id}', type: 'C', x: ${city.x.toFixed(1)}, y: ${city.y.toFixed(1)} },</div>`;
            });

            outputDiv.innerHTML = output;
        }

        function updateAllDistances() {
            const selectedPTId = selectedPTSelect.value;
            const pt = components.find(c => c.id === selectedPTId);
            if (!pt) return;

            distancesDiv.innerHTML = '';
           
            components.filter(c => c.type === 'RT').forEach(rt => {
                const dist = getDistance(pt, rt).toFixed(2);
                const isSignal = isSignalSuccessful(pt, rt, powerRadii[pt.power]);
                const status = rtStates[rt.id] ? `<span class="rt-active">(ON)</span>` : `<span class="rt-inactive">(OFF)</span>`;
               
                let hitStatus;
                if (isSignal) {
                    hitStatus = `<span class="pass">HIT (Clear)</span>`;
                } else if (getDistance(pt, rt) <= powerRadii[pt.power]) {
                    hitStatus = `<span class="fail">BLOCKED!</span>`;
                } else {
                    hitStatus = `<span class="fail">MISS (Out of Range)</span>`;
                }
               
                distancesDiv.innerHTML += `<div>${rt.id}: ${dist} units ${status} ${hitStatus}</div>`;
            });
           
            distancesDiv.innerHTML += `<hr style="border-color:#555">`;

            components.filter(c => c.type === 'C').forEach(city => {
                const dist = getDistance(pt, city).toFixed(2);
                const isSignal = isSignalSuccessful(pt, city, powerRadii[pt.power]);

                let hitStatus;
                if (isSignal) {
                    hitStatus = `<span class="pass">Direct Hit (Clear)</span>`;
                } else if (getDistance(pt, city) <= powerRadii[pt.power]) {
                    hitStatus = `<span class="fail">BLOCKED!</span>`;
                } else {
                    hitStatus = `<span class="fail">Miss (Out of Range)</span>`;
                }

                distancesDiv.innerHTML += `<div>${city.id}: ${dist} units - ${hitStatus}</div>`;
            });
        }

        function updateCoverageDetails() {
            const { coveredCities, totalCities } = getCityCoverage();
            const totalActiveRTs = components.filter(c => c.type === 'RT' && rtStates[c.id]).length;
            const totalActivePTs = components.filter(c => c.type === 'PT' && c.active && c.power > 0).length;

            const validation = checkAllPuzzleRequirements(currentSolveState);
            
            let summaryHTML = '';
            if (currentSolveState === 'custom') {
                summaryHTML = `<div class="not-solved">CUSTOM MODE</div>`;
            } else if (validation.isSolved) {
                summaryHTML = `<div class="solved">STATE ${currentSolveState === 'state1' ? '1' : '2'} SOLVED!</div>`;
            } else {
                summaryHTML = `<div class="not-solved">STATE ${currentSolveState === 'state1' ? '1' : '2'} NOT SOLVED</div>`;
            }

            coverageDetailsDiv.innerHTML = `
                ${summaryHTML}
                <hr style="border-color:#555">
                <div>**Cities Covered:** <span class="pass">${coveredCities.length}</span> / ${totalCities}</div>
                <div>Active PTs (Total): ${totalActivePTs}</div>
                <div>Active RTs (Total): ${totalActiveRTs}</div>
            `;
        }

        function updateCurrentPTStates() {
            currentPTStatesDiv.innerHTML = '';
            const validation = checkAllPuzzleRequirements(currentSolveState);

            components.filter(c => c.type === 'PT' && c.active).forEach(pt => {
                const ptValidation = validation.details.find(d => d.id === pt.id);
                if (!ptValidation) return;

                const { liveChannel, reqChannel, channelMet, cityCoverageMet } = ptValidation;

                const channelStatus = channelMet 
                    ? `<span class="pass">Ch: ${liveChannel}/${reqChannel} ✅</span>` 
                    : `<span class="fail">Ch: ${liveChannel}/${reqChannel} ❌</span>`;
                
                const cityStatus = cityCoverageMet
                    ? `<span class="pass">City ✅</span>`
                    : `<span class="fail">City ❌</span>`;

                currentPTStatesDiv.innerHTML += `
                    <div>
                        ${pt.id} (P${pt.power}) - ${channelStatus} | ${cityCoverageMet ? '' : `<span class="fail">NO CITY COVERAGE</span>`}
                    </div>`;
            });

            components.filter(c => c.type === 'PT' && !c.active).forEach(pt => {
                currentPTStatesDiv.innerHTML += `
                    <div style="color:#666">
                        ${pt.id} (P${pt.power}) - Inactive
                    </div>`;
            });
            
            updateManualControls();
        }

        // New: Renders the dropdown controls for all 18 PTs below the map
        function createManualControls() {
            bottomPtControlsDiv.innerHTML = '';
            const allPTs = components.filter(c => c.type === 'PT');

            allPTs.forEach(pt => {
                const liveChannel = getPT_RT_HitCount(pt);
                
                let powerOptions = '';
                for (let p = 0; p <= 4; p++) {
                    powerOptions += `<option value="${p}" ${pt.power === p ? 'selected' : ''}>P${p}</option>`;
                }
                
                let channelOptions = '';
                for (let c = 1; c <= 3; c++) {
                    channelOptions += `<option value="${c}" ${pt.reqChannel === c ? 'selected' : ''}>Req ${c}</option>`;
                }
                
                const controlHTML = `
                    <div class="pt-control-box" id="ctrl-${pt.id}" onclick="selectPT('${pt.id}')">
                        <h5>${pt.id}</h5>
                        
                        <div class="control-status-row">
                            <button id="toggle-${pt.id}" data-pt-id="${pt.id}">
                                ${pt.active ? 'Active' : 'Inactive'}
                            </button>
                            <select id="pwr-sel-${pt.id}" data-pt-id="${pt.id}" data-type="power">
                                ${powerOptions}
                            </select>
                        </div>

                        <div class="control-status-row">
                            <select id="req-ch-sel-${pt.id}" data-pt-id="${pt.id}" data-type="reqChannel">
                                ${channelOptions}
                            </select>
                            <span class="live-ch-status" id="live-ch-val-${pt.id}">L: ${liveChannel}</span>
                        </div>
                    </div>
                `;
                bottomPtControlsDiv.innerHTML += controlHTML;
            });
            
            // Add global listener after controls are created
            bottomPtControlsDiv.addEventListener('change', handleControlChange);
            bottomPtControlsDiv.addEventListener('click', handleControlClick);

            updateManualControls();
        }

        // --- NEW DELEGATED EVENT HANDLERS ---

        function handleControlChange(event) {
            const target = event.target;
            if (target.tagName === 'SELECT') {
                const ptId = target.id.split('-')[2];
                const type = target.getAttribute('data-type');
                const newValue = parseInt(target.value);

                const pt = components.find(c => c.id === ptId);
                if (pt) {
                    if (currentSolveState !== 'custom') {
                        solveStateSelect.value = 'custom';
                        currentSolveState = 'custom';
                    }

                    if (type === 'power') {
                        pt.power = newValue;
                        pt.active = newValue > 0;
                    } else if (type === 'reqChannel') {
                        pt.reqChannel = newValue;
                    }
                }
                updateControlPanel();
            }
        }

        function handleControlClick(event) {
            const target = event.target;
            if (target.tagName === 'BUTTON' && target.id.startsWith('toggle-')) {
                const ptId = target.getAttribute('data-pt-id');
                togglePT(ptId);
            } else if (target.closest('.pt-control-box')) {
                const ptId = target.closest('.pt-control-box').id.split('-')[1];
                selectPT(ptId);
            }
        }
        
        // Toggles active status
        function togglePT(ptId) {
            const pt = components.find(c => c.id === ptId);
            if (pt) {
                if (currentSolveState !== 'custom') {
                    solveStateSelect.value = 'custom';
                    currentSolveState = 'custom';
                }

                pt.active = !pt.active;
                
                if (pt.active && pt.power === 0) {
                    pt.power = 3; 
                }
                if (!pt.active) {
                    pt.power = 0;
                }
            }
            updateControlPanel();
        }
        
        function selectPT(ptId) {
            selectedPTSelect.value = ptId;
            updateControlPanel(); 
        }
        
        // Updates the UI state of the controls when data changes
        function updateManualControls() {
            components.filter(c => c.type === 'PT').forEach(pt => {
                const liveChannel = getPT_RT_HitCount(pt);
                
                const powerSelect = document.getElementById(`pwr-sel-${pt.id}`);
                const channelSelect = document.getElementById(`req-ch-sel-${pt.id}`);
                const toggleBtn = document.getElementById(`toggle-${pt.id}`);
                const liveChSpan = document.getElementById(`live-ch-val-${pt.id}`);
                
                // Update live data and visual state
                if (liveChSpan) liveChSpan.textContent = liveChannel;
                
                if (toggleBtn) {
                    toggleBtn.textContent = pt.active ? 'Active' : 'Inactive';
                    toggleBtn.style.backgroundColor = pt.active ? '#28a745' : '#dc3545';
                }
                
                // Ensure dropdown values match the PT object state
                if (powerSelect) powerSelect.value = pt.power;
                if (channelSelect) channelSelect.value = pt.reqChannel;
            });
        }
        
        function updateControlPanel() {
            updateRTStates();
            drawComponents();
            updateAllDistances();
            updateCoverageDetails();
            updateCurrentPTStates();
            updateCoordinateOutput(); 
        }
        
        function applySolveStatePresets(state) {
            currentSolveState = state;

            const STATE1_OFF_IDS = ['PT-C', 'PT-F', 'PT-G', 'PT-J', 'PT-N', 'PT-Q']; 
            const STATE2_IDS = ['PT-M', 'PT-N', 'PT-O', 'PT-P', 'PT-Q', 'PT-R'];

            // 1. Reset ALL PTs 
            components.filter(c => c.type === 'PT').forEach(pt => {
                pt.active = false;
                pt.power = 0;
                // Reset required channel (Retain puzzle requirements for display)
                if (pt.id.startsWith('PT-A') || pt.id.startsWith('PT-B') || pt.id.startsWith('PT-D') || pt.id.startsWith('PT-E') || pt.id.startsWith('PT-H') || pt.id.startsWith('PT-I') || pt.id.startsWith('PT-K') || pt.id.startsWith('PT-L')) pt.reqChannel = 1;
                if (pt.id === 'PT-C' || pt.id === 'PT-J' || pt.id === 'PT-M' || pt.id === 'PT-N' || pt.id === 'PT-P' || pt.id === 'PT-Q') pt.reqChannel = 2;
                if (pt.id === 'PT-F' || pt.id === 'PT-G' || pt.id === 'PT-O') pt.reqChannel = 3;
                if (pt.id === 'PT-R') pt.reqChannel = 1;
            });
           
            if (state === 'state1') {
                components.filter(c => c.type === 'PT').forEach(pt => {
                    const isActive = !STATE1_OFF_IDS.includes(pt.id);
                    if (isActive) {
                        pt.active = true;
                        pt.power = pt.reqPower;
                    }
                });
            } else if (state === 'state2') {
                STATE2_IDS.forEach(id => {
                    const pt = components.find(c => c.id === id);
                    if (pt) {
                        pt.active = true;
                        pt.power = pt.reqPower;
                    }
                });
            }
            
            updateControlPanel();
        }

        function initialize() {
            // Populate the "Select PT to Inspect" dropdown
            components.filter(c => c.type === 'PT').forEach(pt => {
                const option = document.createElement('option');
                option.value = pt.id;
                option.textContent = pt.id;
                selectedPTSelect.appendChild(option);
            });
           
            selectedPTSelect.addEventListener('change', updateControlPanel);
            solveStateSelect.addEventListener('change', (event) => {
                applySolveStatePresets(event.target.value);
            });
           
            // Create the list of manual PT controls once
            createManualControls(); 
            
            // Start on State 1 to ensure a functional initial state
            applySolveStatePresets('state1'); 
        }

        // --- RUN INITIALIZATION ---
        initialize();
    </script>
</body>
</html>
